
//Author: Bogdan Trigubov
//Updated: December: 2025
//Description: Class that converts a python file (pasted into toMarkdown.txt) into properly formatted markdown (result replaces what was pasted in toMarkdown.txt). Instance of this class is created in toMd.java and is necessary to run the converter. 
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

public class toMarkdown {
  private ArrayList<String> linesList;
  private ArrayList<String> outputList;
  private String language;

  // Default constructor
  public toMarkdown(String fileName) {
    this.linesList = readFile(fileName);
    this.language = "python";
  }

  // Constructor for custom language
  public toMarkdown(String fileName, String language) {
    this.linesList = readFile(fileName);
    this.language = language;
  }

  public void invert(ArrayList<Integer> updateIndexList) {
    int indexOf_updateIndexList = 0;
    this.outputList = new ArrayList<>();
    boolean isFirstDocstring = true;

    for (int i = 0; i < linesList.size(); i++) {
      String line = linesList.get(i);

      // Skip unwanted lines
      if (shouldSkipLine(line)) {
        continue;
      }

      String string;

      if (i == 0 && line.contains("\"\"\"")) {
        // First docstring becomes title (no watermark)
        string = line.replace("\"\"\"", "# ").trim();
        if (!string.isEmpty() && !string.equals("#")) {
          this.outputList.add(string);
        }
        isFirstDocstring = false;
        continue;
      } else if (indexOf_updateIndexList < updateIndexList.size()
          && i == updateIndexList.get(indexOf_updateIndexList)) {
        if (indexOf_updateIndexList % 2 == 0) { // even - start code block
          string = convertPython(linesList.get(i), language);
        } else { // odd - end code block
          string = convert(linesList.get(i));
        }
        indexOf_updateIndexList++;
      } else {
        string = line;
      }

      this.outputList.add(string);
    }

    // Add final closing ``` if needed
    if (!this.outputList.isEmpty()) {
      String lastLine = this.outputList.get(this.outputList.size() - 1);
      if (!lastLine.trim().equals("```")) {
        this.outputList.add("```");
      }
    }
  }

  private boolean shouldSkipLine(String line) {
    if (line == null)
      return false;
    String trimmed = line.trim();

    // Skip all unwanted lines
    return trimmed.equals("# -*- coding: utf-8 -*-") ||
        trimmed.equals("Automatically generated by Colab.") ||
        trimmed.contains("Automatically converted to markdown by **toMarkdown**") ||
        trimmed.startsWith("Original file is located at") ||
        trimmed.contains("https://colab.research.google.com");
  }

  public ArrayList<Integer> processIndex() {
    String doc = "\"\"\"";
    int docCount = 0;
    ArrayList<Integer> updateIndexList = new ArrayList<>();
    for (int i = 0; i < linesList.size(); i++) {
      String line = linesList.get(i);
      int index = 0;
      boolean lineAdded = false;
      for (char charachter : line.toCharArray()) {
        if (charachter == '\"') {
          try {
            String test = String.valueOf(line.toCharArray()[index]) +
                String.valueOf(line.toCharArray()[index + 1]) +
                String.valueOf(line.toCharArray()[index + 2]);
            if (test.equals(doc) && !lineAdded) {
              if (docCount > 0) {
                updateIndexList.add(i);
                lineAdded = true;
              }
              docCount++;
              lineAdded = true;
            }
          } catch (ArrayIndexOutOfBoundsException e) {
            break;
          }
        }
        index++;
      }
    }
    return updateIndexList;
  }

  public static String convert(String line) {
    String newText = line.replace("\"\"\"", "\n```\n\n");
    return newText;
  }

  public static String convertPython(String line, String language) {
    String newText = line.replace("\"\"\"", "\n```" + language);
    return newText;
  }

  public void print() {
    for (int i = 0; i < linesList.size(); i++) {
      System.out.println(linesList.get(i));
    }
  }

  public static ArrayList<String> readFile(String fileName) {
    ArrayList<String> linesList = new ArrayList<>();
    String line;
    try {
      BufferedReader reader = new BufferedReader(new FileReader(fileName));
      while ((line = reader.readLine()) != null) {
        if (line.contains("\"\"\"")) {
          int firstIndex = line.indexOf("\"\"\"");
          int secondIndex = line.indexOf("\"\"\"", firstIndex + 3);
          if (firstIndex != -1 && secondIndex != -1) {
            String part1 = line.substring(0, secondIndex);
            String part2 = line.substring(secondIndex);
            linesList.add(part1);
            linesList.add(part2);
          } else {
            linesList.add(line);
          }
        } else {
          linesList.add(line);
        }
      }
      reader.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
    return linesList;
  }

  public static boolean isNotebookLine(String line) {
    if (line == null)
      return false;
    return line.matches("^\"\"\".+\\.ipynb$");
  }

  public static String processNotebookLine(String line) {
    if (!isNotebookLine(line)) {
      return line;
    }
    String name = line.substring(3, line.length() - 6);
    return "# " + name;
  }

  public void write(String fileName) {
    try {
      BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));

      // Clean output: remove excessive blank lines and trim code blocks
      ArrayList<String> cleanedOutput = cleanOutput(outputList);
      String watermark = "\nAutomatically converted to markdown by **toMarkdown** _(by Bogdan Trigubov)_";
      writer.write(watermark);
      // Write cleaned output
      for (int i = 0; i < cleanedOutput.size(); i++) {
        if (isNotebookLine(cleanedOutput.get(i))) {
          writer.write("\n" + processNotebookLine(cleanedOutput.get(i)) + "\n");
          continue;
        }
        writer.write(cleanedOutput.get(i));

        // Add newline except for last line
        if (i < cleanedOutput.size() - 1) {
          writer.newLine();
        }
      }

      writer.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  private ArrayList<String> cleanOutput(ArrayList<String> output) {
    ArrayList<String> cleaned = new ArrayList<>();
    int consecutiveBlankLines = 0;
    boolean inCodeBlock = false;

    for (int i = 0; i < output.size(); i++) {
      String line = output.get(i);
      String trimmed = line.trim();

      // Track if we're in a code block
      if (trimmed.startsWith("```")) {
        if (trimmed.length() > 3) {
          // Starting a code block (```python, ```java, etc.)
          inCodeBlock = true;
          cleaned.add(line);
          consecutiveBlankLines = 0;

          // Skip any blank lines immediately after code block start
          while (i + 1 < output.size() && output.get(i + 1).trim().isEmpty()) {
            i++;
          }
          continue;
        } else {
          // Ending a code block (just ```)
          // Remove any blank lines before the closing ```
          while (!cleaned.isEmpty() && cleaned.get(cleaned.size() - 1).trim().isEmpty()) {
            cleaned.remove(cleaned.size() - 1);
          }
          cleaned.add(line);
          inCodeBlock = false;
          consecutiveBlankLines = 0;

          // Add one blank line after closing ``` for proper spacing
          if (i + 1 < output.size()) {
            cleaned.add("");
            consecutiveBlankLines = 1;
          }
          continue;
        }
      }

      // Handle blank lines
      if (trimmed.isEmpty()) {
        consecutiveBlankLines++;
        // Only allow 1 consecutive blank line (unless in code block)
        if (consecutiveBlankLines <= 1) {
          cleaned.add(line);
        }
      } else {
        consecutiveBlankLines = 0;
        cleaned.add(line);
      }
    }

    // Remove trailing blank lines
    while (!cleaned.isEmpty() && cleaned.get(cleaned.size() - 1).trim().isEmpty()) {
      cleaned.remove(cleaned.size() - 1);
    }

    return cleaned;
  }
}
